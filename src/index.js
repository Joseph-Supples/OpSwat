import * as dotenv from 'dotenv';
dotenv.config({path: '.env'});
import * as path from 'path'
import SHA256 from "crypto-js/sha256.js";
import fetch from "node-fetch";
import fs from 'fs';

const key = process.env.API_KEY;



function getFileHash(){
   const content = fs.readFileSync("sample.txt");

   return SHA256(content).toString();
}


async function lookupHash(hash) {

    let url = 'https://api.metadefender.com/v4/hash/'+ hash;
    const response = await fetch(url, {
        headers:{
            'apikey': key
        }
    });
    const responsejson = await response.json();

    if(responsejson.hasOwnProperty('error'))
    {
        console.error(responsejson["error"]["messages"][0]);
        return "Invalid";
    }
    else
    {
        return responsejson["data_id"]
    }
    
}

async function uploadFile() {
    let url = 'https://api.metadefender.com/v4/file';
    let response = await fetch(url,{
        method: 'POST',
        headers:{
            'apikey': key,
            'Content-Type' : "application/octet-stream",
        },
        body: "@sample.txt"
    })
    let responsejson = await response.json();
    opFileHash = responsejson["sha256"];
    return responsejson["data_id"];
}

async function readResults(data_id) {
    let progress = 0;
    while(progress !== 100)
    {    
        let url = 'https://api.metadefender.com/v4/file/' + data_id;
        let response = await fetch(url, {
            headers:{
                'apikey': key
            }
        })
        var responsejson = await response.json();
        progress = responsejson["scan_results"]["progress_percentage"];
        if(progress !== 100)
        {
            console.log("Waiting for the scan to complete");
        }
        await new Promise(resolve => setTimeout(resolve, 2000));
    }
    let keys = Object.keys(responsejson["scan_results"]["scan_details"]);
    console.log("\nFilename: sample.txt \n");
    console.log("overall_status: "+ responsejson["scan_results"]["scan_all_result_a"]+"\n");
    for (let i = 0; i < keys.length; i++) {
        let engine = keys[i];
         console.log("engine: "+ engine+"\n");
         let threat = "Clean"
         if(responsejson["scan_results"]["scan_details"][engine]["scan_result_i"] != 0)
         {
             threat = responsejson["scan_results"]["scan_details"][engine]["threat_found"];
         }
         console.log("threat_found: "+ threat+"\n");
         console.log("scan_result: "+ responsejson["scan_results"]["scan_details"][engine]["scan_result_i"]+"\n");
         console.log("def_time: "+ responsejson["scan_results"]["scan_details"][engine]["def_time"]+"\n");
        
    }
}


// get hash of file
let locFileHash = getFileHash();
console.log("CryptoJs generated hash "+ locFileHash);
var opFileHash = "";


// if data_id is returned, then file has already been scanned
console.log("Looking up by CryptoJs hash");
if(await lookupHash(locFileHash)!= "Invalid")
{
    // print formatted results of scan
    readResults(await lookupHash(locFileHash));
}
else
{
   //otherwise, upload file and store data_id 
   let data_id = await uploadFile();
   //print formatted results of scan
   readResults(data_id);
}

await new Promise(resolve => setTimeout(resolve, 7000));
console.log("looking up by OpSwat generated hash: " + opFileHash);
await new Promise(resolve => setTimeout(resolve, 10000));

//calling lookupHash with the hash generated by OpSwat to prove lookup works/file was stored
if(await lookupHash(opFileHash)!= "Invalid")
{
    console.log("hash already exists");
    readResults(await lookupHash(opFileHash));
}
